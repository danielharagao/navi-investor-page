<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Technical Architecture — Navi</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles.css">
      margin-bottom: 1.5rem;
    }
    pre {
      background: #f8f9fa;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 1rem;
      overflow-x: auto;
    }
    code {
      font-family: 'Courier New', monospace;
    }
    .footer {
      text-align: center;
      color: #888;
      font-size: 0.9rem;
      margin: 2rem 0 1rem 0;
    }
    @media (max-width: 600px) {
      section {
        padding: 1rem;
      }
      h1 {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Navi Desktop App Architecture</h1>
    <div class="tagline">CrewAI Integration & Onboarding Summary</div>
    <p>Technical architecture and user flow documentation</p>
  </header>

  <section>
    <h2>App Overview and Core Features</h2>
    <ul>
      <li><strong>Purpose:</strong> A desktop app built in Python, using Navi (a framework for AI agents) with one Personal Assistant Agent running in verbose mode. It integrates MCP (Model Context Protocol) for tools, specifically Playwright MCP for headed browser navigation (Chrome browser setup).</li>
      <li><strong>AI Models:</strong> Supports multiple leading AI models with configurable selection.</li>
      <li><strong>UI:</strong> ChatGPT-like interface with a sidebar containing a "Chat" list (chat history) and a "Tasks" button. The main screen shows user-agent messages, agent/tool execution logs (inline system messages, no separate log component), and verbose logs.</li>
      <li><strong>Workspace:</strong> JSON files for local persistence (speed, safety, manageability). Folders: one for chats (per-chat JSON) and one for tasks (each with Objective, Description, and Deliverable).</li>
      <li><strong>Build:</strong> Desktop app for Windows and macOS (not web). On first message, the chat displays the message, and the agent thinks/runs in verbose mode.</li>
      <li><strong>Tasks Feature:</strong> Initially included but later removed to focus on chat + MCP. If re-added, users could view/run/create/edit tasks, with the chat contracting to the right (like Cursor/Windsurf view).</li>
      <li><strong>Initial Spec Evolution:</strong> Started with task management, custom tools, and DALL·E for forms, but simplified to chat-only, removed tasks, and switched to native web forms.</li>
    </ul>

    <h2>Onboarding and Paid Conversion Flow</h2>
    <p><strong>High-Level Flow:</strong> Visitors → Paid Users via a modern, seamless web-to-desktop journey. Emphasizes marketing/product blend, with clear expectations (paid app, early adopter program).</p>

    <h3>Key Principles</h3>
    <ul>
      <li>Separate <strong>Leads table</strong> (from web form) and <strong>Users table</strong> (created only after desktop app email input).</li>
      <li>Backend/Auth API handles emails (download link, password creation), not the website.</li>
      <li>Token verification always on backend (not local).</li>
      <li>Local persistence: Token and last email (secure storage like Keychain/OS); never store passwords.</li>
      <li>Security: Emails from backend, no local token validation.</li>
    </ul>

    <h3>Detailed Steps (Web → Desktop)</h3>
    <ol>
      <li><strong>Landing Page (Web):</strong> Marketing site with value prop, early adopter CTA, and paid app clarity.</li>
      <li><strong>Form Submission (Web → Backend):</strong> Native form (name, email, consent) → Backend saves to Leads table → Returns OK to site.</li>
      <li><strong>Email with Download Link (Backend → Email):</strong> Backend sends email with download page link (Win/macOS buttons).</li>
      <li><strong>Download & Install (Desktop):</strong> User downloads/installs app.</li>
      <li><strong>Token Verification (Desktop → Backend):</strong> App checks local token; if invalid/missing, prompts for email.</li>
      <li><strong>Email/Password Flow (Desktop + Backend + Email + Web):</strong>
        <ul>
          <li>If no user (lead only): Backend creates user from lead (password_empty=true), sends password creation email.</li>
          <li>If user exists but password_empty=true: Resends password creation email.</li>
          <li>If active user: Prompts for password in app.</li>
        </ul>
      </li>
      <li><strong>Login (Desktop → Backend):</strong> Email + password → Backend issues token → App authenticates.</li>
      <li><strong>Persistence (Desktop):</strong> Saves token/last email securely.</li>
      <li><strong>Paid Gate (Desktop):</strong> If not paid, prompts to activate subscription → Billing page → Stripe payment → Full features.</li>
    </ol>

    <h3>Visual Diagrams</h3>
    <ul>
      <li><strong>ASCII Flow:</strong> Web (LP → Form → Backend saves lead → Email download link → Download page → Download app) → Desktop (App start → Verify token → Email input → User exists? → Password empty? → Password input → Logged area → Paid? → Subscription prompt → Billing → Payment → Full features).</li>
      <li><strong>Mermaid BPMN/Userflow:</strong> Swimlanes for Website, Email, Desktop App, Billing/Stripe. Includes gates like "User account active?" and "Paid user?".</li>
      <li><strong>Sequence Diagram:</strong> Actors: User, Website, Email Service, Desktop App, Backend/Auth API, Billing/Stripe. Covers signup, download, token check, user creation, login, and payment.</li>
    </ul>

    <h3>Pseudocode for Auth</h3>
    <pre><code># on app start
local_token = storage.read("auth_token")
if local_token:
    if not api.verify_token(local_token):  # backend verifies
        local_token = None

if not local_token:
    email = ui.prompt_email()
    user = api.lookup_user(email)
    if not user:
        # creates user from lead and sends email for password creation
        api.create_user_from_lead_and_send_setup(email)
        ui.info("We sent a link to create your password. Return to the app after completing.")
        return
    if user.password_empty:
        api.send_password_setup(email)
        ui.info("We sent a link to create your password. Return to the app after completing.")
        return
    password = ui.prompt_password()
    token = api.login(email, password)
    storage.save_secure("auth_token", token)
    storage.save("last_email", email)
else:
    token = local_token

app.session = token
ui.proceed_to_main()</code></pre>

    <h2>Web Assets to Build</h2>
    <ul>
      <li><strong>Landing Page:</strong> Marketing page with early adopter CTA.</li>
      <li><strong>Native Form:</strong> Simple form (name, email, consent) → Leads table.</li>
      <li><strong>Download Page:</strong> Accessed via email link; buttons for Win/macOS downloads.</li>
      <li><strong>Create Password Page:</strong> Via email link; user sets initial password.</li>
      <li><strong>Success/Confirmation Pages:</strong> E.g., "Password created—return to app," "Download started."</li>
      <li><strong>Rationale:</strong> Minimal, consistent with LP branding; no DALL·E or Tally.</li>
    </ul>

    <h2>Technical Architecture</h2>
    <ul>
      <li><strong>Navi Integration:</strong> 1 agent with MCP tools (Playwright for browser); verbose mode for logs.</li>
      <li><strong>MCP Wiring:</strong> Only Playwright MCP (stdio); custom tools local (not MCP).</li>
      <li><strong>Data Flow:</strong> Website → Backend (leads); App → Backend (auth, token); Emails from Backend.</li>
      <li><strong>Packaging:</strong> Python app with PySide6 UI skeleton (sidebar, chat view, tasks view if added).</li>
      <li><strong>Security:</strong> Backend token validation; secure local storage; no password persistence.</li>
    </ul>

    <h2>Evolution and Corrections</h2>
    <ul>
      <li><strong>Initial Draft:</strong> Included tasks, DALL·E forms, local token checks—removed/simplified.</li>
      <li><strong>Corrections:</strong> Form via native web (not DALL·E); backend sends download email; token always backend-verified; users table only after app email; leads separate.</li>
      <li><strong>Open Questions:</strong> Export to BPMN 2.0 XML, .drawio, or .plantuml for diagrams; add PySide6 signals/slots; minimal custom_mcp_server.py stub.</li>
    </ul>

    <p>This summary captures the iterative refinement of the app's PRD, architecture, and onboarding.</p>
  </section>

  <div class="footer">
    <p><a href="../index.html">← Back to Main Pitch</a> | Navi Technical Architecture</p>
  </div>
</body>
</html></content>
<parameter name="filePath">c:\Users\daniel.aragao\Documents\Coding\mcp agents\Navi\architecture.html